00:02 Are you excited? I know I am, we've been juggling around 
00:06 and working around the fact we don't really have a database
00:09 or data access to make our dynamic websites, so far.
00:13 I've been trying to tech you the web foundations 
00:15 and now that we are through that section 
00:17 it's time to finally have truly data-driven web applications. 
00:21 We are going to use SQLAlchemy. 
00:24 SQLAlchemy is the most flexible, powerful, 
00:27 and popular data access toolkit for Python. 
00:31 Here you can see at SQLAlchemy.org you can find it, 
00:33 of course, "pip install SQLAlchemy" is how we are going to get started.
00:37 Let's look at a few reasons why in addition to being powerful, fast and popular 
00:41 we might choose SQLAlchemy, a little more nuanced look there. 
00:45 We'll see that SQLAlchemy is more than just an ORM, 
00:49 there is several layers to it, and we'll talk about these layers in a moment, 
00:53 so there is a low level core that abstracts
00:56 the differences between different databases, 
00:59 like talking to Microsoft SQL server versus Oracle versus MySql, 
01:03 these all have a slightly different syntaxes 
01:06 and you don't have to care or know about those, 
01:08 you could easily switch between them, 
01:09 but the core's otherwise similar to something where you express your queries 
01:14 in exactly the scheme of the database itself. 
01:18 So you can use this, there is no ORM required, 
01:21 although we are going to be using it in our apps for the most part. 
01:24 It's mature and it's very high-performance. 
01:27 Mike Bayer, the creator of SQLAlchemy, has done a lot of work 
01:30 to highly optimize SQLAlchemy. 
01:33 It's DBA-approved, so for whatever reason you have a DBA 
01:38 who doesn't like ORMs or automatic query generation or SQL generation, 
01:43 you can actually swap out with what is generated by SQLAlchemy 
01:47 with hand-written statements. 
01:51 It does have a very powerful and easy to use ORM 
01:54 while the ability to work without an ORM for certain queries and situations is great, 
01:59 you'll see, my philosophy is 80, 90% of the time, 
02:02 the ORM saves you so much time and energy and provides flexibility 
02:08 without getting in your way that you can do
02:11 just the raw SQL or core level queries just for the few ones
02:15 that don't quite fit with what you are doing. 
02:18 SQLAlchemy uses the "unit of work" design pattern, 
02:21 this is as opposed to "active record", and this is I think 
02:24 a slightly more sophisticated data access design pattern. 
02:27 What that means is you begin unit of work, you make some queries, 
02:31 make some changes, make some updates, deletes maybe 
02:34 and you do all of your database work and then you commit the unit of work 
02:38 and all those changes are either applied 
02:40 or none of them are applied all in one batch, 
02:43 as opposed to inserting individual records 
02:45 and hoping that everything hangs together.
02:48 It supports many databases, SQLlite, that's the one we are going to be using, 
02:53 MySQL, Microsoft SQL, Oracle and so on. 
02:56 It also supports something called Eager-loading, as well as lazy loading. 
03:02 So Eager-loading is the ability to say to the query engine 
03:05 "hey, I am actually going to query this collection 
03:08 but I am going to do traversal of a relationship over to these two others" 
03:12 and instead of doing that lazily, which is a really big problem for performance, 
03:16 in certain circumstances, you can tell it to do that all in one shot 
03:20 as one sort of three way join and you have only one database access 
03:24 instead of using lazy loading, which is really cool. 
03:27 So SQLAlchemy is a great toolkit, it's what I use on all the Talk Python websites, 
03:31 it's what is driving this website that you are looking at right now. 